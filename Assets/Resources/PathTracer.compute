#pragma kernel PathTracer

#pragma multi_compile __ HAS_TLAS
#pragma multi_compile __ HAS_TEXTURES
#pragma multi_compile __ HAS_ENVIRONMENT_TEXTURE
#pragma multi_compile __ HAS_LIGHTS

#if HAS_TLAS
#include "util/tlas.hlsl"
#else
#include "util/bvh.hlsl"
#endif

#include "util/camera.hlsl"
#include "util/common.hlsl"
#include "util/pathtrace.hlsl"
#include "util/random.hlsl"
#include "util/ray.hlsl"

int SamplesPerPass;

// Using a 2D dispatch causes a warning for exceeding the number of temp variable registers.
[numthreads(128, 1, 1)]
void PathTracer(uint3 id : SV_DispatchThreadID)
{
    const uint pixelIndex = id.x;
    const uint pixelX = pixelIndex % OutputWidth;
    const uint pixelY = pixelIndex / OutputWidth;
    if (pixelX >= OutputWidth || pixelY >= OutputHeight)
        return;

    float2 pixelCoords = float2(pixelX, pixelY);

    const int numSamples = max(1, SamplesPerPass);
    float fSamples = (float)numSamples;
    uint rngState = RNGStateBuffer[pixelIndex];

    float3 color = 0.0f;
    for (int sampleIndex = 0; sampleIndex < numSamples; ++sampleIndex)
    {
        float2 randomSample = float2(RandomFloat(rngState), RandomFloat(rngState));

        float2 pixelCoordsSample = pixelCoords + randomSample;

        Ray ray = GetScreenRay(pixelCoordsSample, rngState);

        color += PathTrace(ray, rngState);
    }

    float4 currentColor = AccumulatedOutput[pixelCoords];
    float3 accumilatedColor = (color + currentColor.rgb * CurrentSample) / (CurrentSample + fSamples);

    Output[pixelCoords] = float4(accumilatedColor, 1.0f);

    RNGStateBuffer[pixelIndex] = rngState;
}
