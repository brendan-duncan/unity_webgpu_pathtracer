#pragma kernel PathTracer

#pragma multi_compile __ HAS_TEXTURES

#include "util/bvh.hlsl"
#include "util/camera.hlsl"
#include "util/common.hlsl"
#include "util/material.hlsl"
#include "util/random.hlsl"
#include "util/ray.hlsl"
#include "util/scatter.hlsl"
#include "util/sky.hlsl"

#define NUM_SAMPLES 1
#define RAY_BOUNCES 10

bool ScatterRay(inout Ray ray, RayHit hit, inout uint rngSeed)
{
    //float3x3 uvw = GetBasisMatrix(hit.normal);
    float3 diffuseDir = RandomCosineHemisphere(hit.normal, rngSeed);

    ray.origin = hit.position;
    ray.direction = diffuseDir;

    //doSpecular = select(0.0, 1.0, rand2D() < hitRec.material.specularStrength);

    // var diffuse_dir = uniform_sampling_hemisphere();
    // var diffuse_dir = cosine_sampling_hemisphere();
    // if(near_zero(diffuse_dir)) {
    // 	diffuse_dir = hitRec.normal;
    // }

    // scattered = Ray(hitRec.p, normalize(diffuse_dir));

    return true;
}

float3 TraceRay2(Ray ray, inout uint rngSeed)
{
    float3 accumilatedRadiance = (float3)0.0f;
    float3 throughput = (float3)1.0f;

    for (int i = 0; i < RAY_BOUNCES; ++i)
    {
        RayHit hit = RayIntersectBvh(ray);
        bool didHit = hit.distance < FarPlane;
        if (!didHit)
        {
            accumilatedRadiance += throughput * SampleSkyRadiance(ray.direction);
            break;
        }

        float3 albedoSample = GetAlbedoColor(hit.material, hit.uv);
        float metallic = hit.material.metallicRoughness.r;
        float roughness = hit.material.metallicRoughness.g;
        float ior = hit.material.ior;

        float3 emissionColor = hit.material.emission;
        accumilatedRadiance += emissionColor * throughput;
        throughput *= albedoSample;

        ScatterRay(ray, hit, rngSeed);

        float nDotR = dot(ray.direction, hit.normal);
        if (nDotR > 0.0f)
        {
            throughput *= nDotR * (1.0f / PI);
        }
        else
        {
            break;
        }
    }

    return accumilatedRadiance;
}

float3 TraceRay(Ray ray, inout uint rngSeed)
{
    int rayBounces = 0;
    float3 color = (float3)1.0f;

    while (rayBounces < RAY_BOUNCES)
    {
        RayHit hit = RayIntersectBvh(ray);
        bool didHit = hit.distance < FarPlane;
        if (didHit)
        {           
            float3 attenuation = (float3)0;
            if (hit.material.mode == 3)
            {
                if (!ScatterDielectric(hit, ray, attenuation, rngSeed))
                {
                    return color;
                }
            }
            else
            {
                float metallic = hit.material.metallicRoughness.r;
                if (metallic > 0.0f)
                {
                    Ray lambertRay = {ray.origin, ray.direction};
                    if (!ScatterMetal(hit, ray, attenuation, rngSeed))
                    {
                        return color;
                    }
                    if (metallic < 1.0f)
                    {
                        float3 lambert = (float3)0;
                        if (!ScatterLambertian(hit, lambertRay, lambert, rngSeed))
                        {
                            return color;
                        }

                        ray.direction = lerp(ray.direction, lambertRay.direction, metallic);

                        attenuation = lerp(attenuation, lambert, metallic);
                    }
                }
                else 
                {
                    if (!ScatterLambertian(hit, ray, attenuation, rngSeed))
                    {
                        return color;
                    }
                }
            }

            color *= attenuation;
            
            rayBounces++;
        }
        else
        {
            if (SkyMode == 0)
            {
                color *= BackgroundColor(ray.direction);
            }
            else
            {
                float3 v = ray.direction;
                float3 s = SkyStateBuffer[0].sunDirection;

                float theta = acos(v.y);
                float gamma = acos(clamp(dot(v, s), -1.0, 1.0));

                float3 skyRadiance = float3(
                    SkyRadiance(theta, gamma, 0),
                    SkyRadiance(theta, gamma, 1),
                    SkyRadiance(theta, gamma, 2)
                );

                color *= skyRadiance;
            }

            break;
        }
    }

    return color;
}

[numthreads(128, 1, 1)]
void PathTracer(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= TotalRays)
    {
        return;
    }

    const uint rayIndex = id.x;
    const uint pixelX = rayIndex % OutputWidth;
    const uint pixelY = rayIndex / OutputWidth;
    float2 pixelCoords = float2(pixelX, pixelY);

    uint pixelIndex = pixelY * OutputWidth + pixelX;
    uint rngSeed = RNGStateBuffer[pixelIndex];

    float3 color = 0.0f;
    #if NUM_SAMPLES > 1
    for (int sampleIndex = 0; sampleIndex < NUM_SAMPLES; ++sampleIndex)
    #else
    const int sampleIndex = 1;
    #endif
    {       
        float2 randomSample = float2(rngInRange(0.0, 1.0, rngSeed), rngInRange(0.0, 1.0, rngSeed));
        
        float2 pixelCoordsSample = pixelCoords + randomSample;
        
        Ray ray = GetScreenRay(pixelCoordsSample);

        color += TraceRay(ray, rngSeed);
    }
    #if NUM_SAMPLES > 1
    color /= (float)NUM_SAMPLES;
    #endif

    float3 currentColor = AccumulatedOutput[pixelCoords].rgb;
    float3 accumilatedColor = (color + currentColor * CurrentSample) / (CurrentSample + 1.0f);

    Output[pixelCoords] = float4(accumilatedColor, 1.0f);

    RNGStateBuffer[pixelIndex] = rngSeed;
}
