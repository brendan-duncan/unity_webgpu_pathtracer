#pragma kernel PathTracer

#include "util/bvh.hlsl"
#include "util/camera.hlsl"
#include "util/common.hlsl"
#include "util/material.hlsl"
#include "util/random.hlsl"
#include "util/ray.hlsl"
#include "util/scatter.hlsl"
#include "util/sky.hlsl"

#define NUM_SAMPLES 10
#define RAY_BOUNCES 10

bool ShadowRay(Ray ray, float tMax)
{
    RayHit hit = RayIntersectBvh(ray);
    return hit.t >= tMax;
}

float3 TraceRay(Ray ray, inout uint rngSeed)
{
    int rayBounces = RAY_BOUNCES;
    float3 color = (float3)1.0f;
    float3 radiance = (float3)0.0f;

    while (rayBounces >= 0)
    {
        RayHit hit = RayIntersectBvh(ray);
        bool didHit = hit.t < FarPlane;
        if (didHit)
        {
            /*float2 u = float2(rngInRange(0.0, 1.0, rngSeed), rngInRange(0.0, 1.0, rngSeed));
            float3 lightDirection = SampleSolarDiskDirection(u, SOLAR_COS_THETA_MAX, SkyStateBuffer[0].sunDirection);
            float3 lightIntensity = float3(
                SkyStateBuffer[0].solarRadiances[0],
                SkyStateBuffer[0].solarRadiances[1],
                SkyStateBuffer[0].solarRadiances[2]);
            Ray lightRay = {ray.origin + ray.direction * hit.t, lightDirection};
            bool lightVisibility = ShadowRay(lightRay, FarPlane);*/

            float3 attenuation = (float3)0;
            if (hit.material.mode == 3)
            {
                if (!ScatterDielectric(hit, ray, attenuation, rngSeed))
                {
                    return color;
                }
            }
            else
            {
                float metalic = hit.material.metalicSmoothness.r;
                if (metalic > 0.0f)
                {
                    Ray lambertRay = {ray.origin, ray.direction};
                    if (!ScatterMetal(hit, ray, attenuation, rngSeed))
                    {
                        return color;
                    }
                    if (metalic < 1.0f)
                    {
                        float3 lambert = (float3)0;
                        if (!ScatterLambertian(hit, lambertRay, lambert, rngSeed))
                        {
                            return color;
                        }

                        ray.direction = lerp(ray.direction, lambertRay.direction, metalic);

                        attenuation = lerp(attenuation, lambert, metalic);
                    }
                }
                else 
                {
                    if (!ScatterLambertian(hit, ray, attenuation, rngSeed))
                    {
                        return color;
                    }
                }
            }

            //radiance += lightIntensity * lightVisibility * SOLAR_INV_PDF;
            //radiance += attenuation;
            color *= attenuation;
            
            rayBounces--;
        }
        else
        {
            if (SkyMode == 0)
            {
                color *= BackgroundColor(ray.direction);
            }
            else
            {
                float3 v = ray.direction;
                float3 s = SkyStateBuffer[0].sunDirection;

                float theta = acos(v.y);
                float gamma = acos(clamp(dot(v, s), -1.0, 1.0));

                float3 skyRadiance = float3(
                    SkyRadiance(theta, gamma, 0),
                    SkyRadiance(theta, gamma, 1),
                    SkyRadiance(theta, gamma, 2)
                );

                color *= skyRadiance;
            }

            return color;
        }
    }

    return color;
}

[numthreads(128, 1, 1)]
void PathTracer(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= TotalRays)
    {
        return;
    }

    const uint rayIndex = id.x;
    const uint pixelX = rayIndex % OutputWidth;
    const uint pixelY = rayIndex / OutputWidth;
    float2 pixelCoords = float2(pixelX, pixelY);

    uint pixelIndex = pixelY * OutputWidth + pixelX;
    uint rngSeed = RNGStateBuffer[pixelIndex];

    float3 color = 0.0f;
    #if NUM_SAMPLES > 1
    for (int sampleIndex = 0; sampleIndex < NUM_SAMPLES; ++sampleIndex)
    #else
    const int sampleIndex = 1;
    #endif
    {       
        float2 randomSample = float2(rngInRange(0.0, 1.0, rngSeed), rngInRange(0.0, 1.0, rngSeed));
        
        float2 pixelCoordsSample = pixelCoords + randomSample;
        
        Ray ray = GetScreenRay(pixelCoordsSample);

        color += TraceRay(ray, rngSeed);
    }
    #if NUM_SAMPLES > 1
    color /= (float)NUM_SAMPLES;
    #endif

    float3 currentColor = AccumulatedOutput[pixelCoords].rgb;
    float3 accumilatedColor = (color + currentColor * CurrentSample) / (CurrentSample + 1.0f);

    Output[pixelCoords] = float4(accumilatedColor, 1.0f);

    RNGStateBuffer[pixelIndex] = rngSeed;
}
