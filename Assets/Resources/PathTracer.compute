#pragma kernel PathTracer

#pragma multi_compile __ HAS_TLAS
#pragma multi_compile __ HAS_TEXTURES
#pragma multi_compile __ HAS_ENVIRONMENT_TEXTURE
#pragma multi_compile __ HAS_LIGHTS

#if HAS_TLAS
#include "util/tlas.hlsl"
#else
#include "util/bvh.hlsl"
#endif

#include "util/camera.hlsl"
#include "util/common.hlsl"
#include "util/pathtrace.hlsl"
#include "util/random.hlsl"

uint RngSeedRoot;
int SamplesPerPass;

//[numthreads(128, 1, 1)]
//[numthreads(8, 8, 1)]
[numthreads(32, 32, 1)]
void PathTracer(uint3 gid : SV_DispatchThreadID, uint3 tid : SV_GroupThreadID)
{
    //const uint pixelIndex = gid.x;
    //const uint pixelX = pixelIndex % OutputWidth;
    //const uint pixelY = pixelIndex / OutputWidth;
    const uint pixelX = gid.x;
    const uint pixelY = gid.y;
    const uint pixelIndex = pixelY * OutputWidth + pixelX;

    if (pixelX < OutputWidth && pixelY < OutputHeight)
    {
        float2 pixelCoords = float2(pixelX, pixelY);

        const int numSamples = max(1, SamplesPerPass);
        const float fSamples = (float)numSamples;
        uint rngState = pixelIndex * (CurrentSample + 1) + RngSeedRoot;

        float3 color = 0.0f;
        int sampleIndex = 0;
        for (; sampleIndex < numSamples; ++sampleIndex)
        {
            float2 randomSample = float2(RandomFloat(rngState), RandomFloat(rngState));

            float2 pixelCoordsSample = pixelCoords + randomSample;

            Ray ray = GetScreenRay(pixelCoordsSample, rngState);

            color += PathTrace(ray, rngState);
        }

        float4 currentColor = AccumulatedOutput[pixelCoords];
        float3 accumilatedColor = (color + currentColor.rgb * CurrentSample) / (CurrentSample + fSamples);
        Output[pixelCoords] = float4(accumilatedColor, 1.0f);
    }
}
