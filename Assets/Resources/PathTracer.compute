#pragma kernel PathTracer

#pragma multi_compile __ HAS_TEXTURES
#pragma multi_compile __ HAS_ENVIRONMENT_TEXTURE

#include "util/bvh.hlsl"
#include "util/camera.hlsl"
#include "util/common.hlsl"
#include "util/material.hlsl"
#include "util/monte_carlo.hlsl"
#include "util/pathtrace.hlsl"
#include "util/random.hlsl"
#include "util/ray.hlsl"
#include "util/sky.hlsl"

int SamplesPerPass;

//#define NUM_SAMPLES 1

[numthreads(128, 1, 1)]
void PathTracer(uint3 id : SV_DispatchThreadID) {
    if (id.x >= TotalRays) {
        return;
    }

    const int numSamples = max(1, SamplesPerPass);

    const uint rayIndex = id.x;
    const uint pixelX = rayIndex % OutputWidth;
    const uint pixelY = rayIndex / OutputWidth;
    float2 pixelCoords = float2(pixelX, pixelY);

    uint pixelIndex = pixelY * OutputWidth + pixelX;
    uint rngSeed = RNGStateBuffer[pixelIndex];

    float3 color = 0.0f;
    //#if NUM_SAMPLES > 1
    //for (int sampleIndex = 0; sampleIndex < NUM_SAMPLES; ++sampleIndex)
    //#endif
    for (int sampleIndex = 0; sampleIndex < numSamples; ++sampleIndex)
    {
        float2 randomSample = float2(RandomFloat(rngSeed), RandomFloat(rngSeed));

        float2 pixelCoordsSample = pixelCoords + randomSample;

        Ray ray = GetScreenRay(pixelCoordsSample);

        color += TraceRayMonteCarlo(ray, rngSeed);
    }

    if (numSamples > 1)
        color /= (float)numSamples;
    //#if NUM_SAMPLES > 1
    //color /= (float)NUM_SAMPLES;
    //#endif

    float4 currentColor = AccumulatedOutput[pixelCoords];
    float3 accumilatedColor = (color + currentColor.rgb * CurrentSample) / (CurrentSample + 1.0f);

    Output[pixelCoords] = float4(accumilatedColor, 1.0f);

    RNGStateBuffer[pixelIndex] = rngSeed;
}
