#pragma kernel PathTracer

#include "Common.cginc"

float4x4 CamToWorld;
float4x4 CamInvProj;

// Nodes in CWBVH format.
struct BVHNode
{
    float4 n0;
    float4 n1;
    float4 n2;
    float4 n3;
    float4 n4;
};

StructuredBuffer<BVHNode> BVHNodes;
StructuredBuffer<float4> BVHTris;

#define NUM_SAMPLES 1
//#define RAY_BOUNCES 450
#define RAY_BOUNCES 10

// Stack size for BVH traversal
#define STACK_SIZE 32

uint ExtractByte(uint value, uint byteIndex)
{
    return (value >> (byteIndex * 8)) & 0xFF;
}

// Extracts each byte from the float into the channel of a float4
float4 ExtractBytes(float value)
{
    uint packed = asuint(value);

    float4 channels = float4(
        ExtractByte(packed, 0),
        ExtractByte(packed, 1),
        ExtractByte(packed, 2),
        ExtractByte(packed, 3)
    );

    return channels;
}

float3 GetNodeInvDir(float n0w, float3 invDir)
{
    uint packed = asuint(n0w);

    // Extract each byte and sign extend
    uint e_x = (ExtractByte(packed, 0) ^ 0x80) - 0x80;
    uint e_y = (ExtractByte(packed, 1) ^ 0x80) - 0x80;
    uint e_z = (ExtractByte(packed, 2) ^ 0x80) - 0x80;

    return float3(
        asfloat((e_x + 127) << 23) * invDir.x,
        asfloat((e_y + 127) << 23) * invDir.y,
        asfloat((e_z + 127) << 23) * invDir.z
    );
}

uint IntersectCWBVHNode(float3 origin, float3 invDir, uint octinv4, float tmax, const BVHNode node)
{
    uint hitmask = 0;
    float3 nodeInvDir = GetNodeInvDir(node.n0.w, invDir);
    float3 nodePos = (node.n0.xyz - origin) * invDir;
    
    // i = 0 checks the first 4 children, i = 1 checks the second 4 children.
    [unroll]
    for (int i = 0; i < 2; ++i)
    {
        uint meta = asuint(i == 0 ? node.n1.z : node.n1.w);
        
        float4 lox = ExtractBytes(invDir.x < 0.0f ? (i == 0 ? node.n3.z : node.n3.w) : (i == 0 ? node.n2.x : node.n2.y));
        float4 loy = ExtractBytes(invDir.y < 0.0f ? (i == 0 ? node.n4.x : node.n4.y) : (i == 0 ? node.n2.z : node.n2.w));
        float4 loz = ExtractBytes(invDir.z < 0.0f ? (i == 0 ? node.n4.z : node.n4.w) : (i == 0 ? node.n3.x : node.n3.y));
        float4 hix = ExtractBytes(invDir.x < 0.0f ? (i == 0 ? node.n2.x : node.n2.y) : (i == 0 ? node.n3.z : node.n3.w));
        float4 hiy = ExtractBytes(invDir.y < 0.0f ? (i == 0 ? node.n2.z : node.n2.w) : (i == 0 ? node.n4.x : node.n4.y));
        float4 hiz = ExtractBytes(invDir.z < 0.0f ? (i == 0 ? node.n3.x : node.n3.y) : (i == 0 ? node.n4.z : node.n4.w));
                             
        float4 tminx = lox * nodeInvDir.x + nodePos.x;
        float4 tmaxx = hix * nodeInvDir.x + nodePos.x;
        float4 tminy = loy * nodeInvDir.y + nodePos.y;
        float4 tmaxy = hiy * nodeInvDir.y + nodePos.y;
        float4 tminz = loz * nodeInvDir.z + nodePos.z;
        float4 tmaxz = hiz * nodeInvDir.z + nodePos.z;
                        
        float4 cmin = max(max(max(tminx, tminy), tminz), 0.0f);
        float4 cmax = min(min(min(tmaxx, tmaxy), tmaxz), tmax);
        
        uint isInner = (meta & (meta << 1)) & 0x10101010;
        uint innerMask = (isInner >> 4) * 0xffu;
        uint bitIndex = (meta ^ (octinv4 & innerMask)) & 0x1F1F1F1F;
        uint childBits = (meta >> 5) & 0x07070707;

        [unroll]
        for (int j = 0; j < 4; ++j)
        {
            if (cmin[j] <= cmax[j])
            {
                uint shiftBits = (childBits >> (j * 8)) & 255;
                uint bitShift = (bitIndex >> (j * 8)) & 31;
                hitmask |= shiftBits << bitShift;
            }
        }
    }

    return hitmask;
}

float2 InterpolateAttribute(float2 barycentric, float2 attr0, float2 attr1, float2 attr2)
{
    return attr0 * (1.0f - barycentric.x - barycentric.y) + attr1 * barycentric.x + attr2 * barycentric.y;
}

float3 InterpolateAttribute(float2 barycentric, float3 attr0, float3 attr1, float3 attr2)
{
    return attr0 * (1.0f - barycentric.x - barycentric.y) + attr1 * barycentric.x + attr2 * barycentric.y;
}

void IntersectTriangle(int triAddr, const Ray ray, inout RayHit hit)
{
    float3 v0 = BVHTris[triAddr].xyz;
    float3 e1 = BVHTris[triAddr + 1].xyz - v0;
    float3 e2 = BVHTris[triAddr + 2].xyz - v0;
    
    float3 r = cross(ray.direction.xyz, e2);
    float a = dot(e1, r);
            
    if (abs(a) > 0.0000001f)
    {
        float f = 1.0f / a;
        float3 s = ray.origin.xyz - v0;
        float u = f * dot(s, r);
        
        if (u >= 0.0f && u <= 1.0f)
        {
            float3 q = cross(s, e1);
            float v = f * dot(ray.direction.xyz, q);
            
            if (v >= 0.0f && u + v <= 1.0f)
            {
                float d = f * dot(e2, q);
                
                if (d > 0.0f && d < hit.t)
                {
                    hit.barycentric = float2(u, v);
                    hit.triIndex = asuint(BVHTris[triAddr].w);

                    TriangleAttributes triAttr = TriangleAttributesBuffer[hit.triIndex];
                    hit.normal = normalize(InterpolateAttribute(hit.barycentric, triAttr.normal0, triAttr.normal1, triAttr.normal2));
                    // Skip the back face of the triangle
                    if (dot(hit.normal, ray.direction) < 0.0f)
                    {
                        hit.t = d;
                    }
                }
            }
        }
    }
}

void rngNextInt(inout uint state)
{
    // PCG random number generator
    // Based on https://www.shadertoy.com/view/XlGcRh
    uint oldState = state + 747796405u + 2891336453u;
    uint word = ((oldState >> ((oldState >> 28u) + 4u)) ^ oldState) * 277803737u;
    state = (word >> 22u) ^ word;
}

float rngNextFloat(inout uint state)
{
    rngNextInt(state);
    return (float)state / (float)(0xffffffffu);
}

float rngInRange(float min, float max, inout uint state) {
    return min + rngNextFloat(state) * (max - min);
}

float3 rngInSphere(inout uint state)
{
    float3 p = float3(0.0f, 0.0f, 0.0f);
    do
    {
        p = 2.0f * float3(rngNextFloat(state), rngNextFloat(state), rngNextFloat(state)) - float3(1.0f, 1.0f, 1.0f);
    } while (length(p * p) > 1.0f);

    return p;
}

RayHit CastRayCWBVH(const Ray ray)
{
    RayHit hit = (RayHit)0;
    hit.t = FarPlane;

    float3 invDir = rcp(ray.direction.xyz);
    uint octinv4 = (7 - ((ray.direction.x < 0 ? 4 : 0) | (ray.direction.y < 0 ? 2 : 0) | (ray.direction.z < 0 ? 1 : 0))) * 0x1010101;
    
    uint2 stack[STACK_SIZE];
    uint stackPtr = 0;
    uint2 nodeGroup = uint2(0, 0x80000001);
    uint2 triGroup = uint2(0, 0);
    int count = 0;

    while (true)
    {
        if (nodeGroup.y > 0x00FFFFFF)
        {
            if (nodeGroup.y == 0x80000001)
            {
                nodeGroup.y -= 1;
            }
            count += 1;
            uint mask = nodeGroup.y;
            uint childBitIndex = firstbithigh(mask);
            uint childNodeBaseIndex = nodeGroup.x;
            
            nodeGroup.y &= ~(1 << childBitIndex);
            if (nodeGroup.y > 0x00FFFFFF) 
            { 
                // Push onto stack
                stack[stackPtr++] = nodeGroup;
            }
            
            uint slotIndex = (childBitIndex - 24) ^ (octinv4 & 255);
            uint relativeIndex = countbits(mask & ~(0xFFFFFFFF << slotIndex));
            uint childNodeIndex = childNodeBaseIndex + relativeIndex;

            BVHNode node = BVHNodes[childNodeIndex];
            uint hitmask = IntersectCWBVHNode(ray.origin, invDir, octinv4, hit.t, node);

            nodeGroup.x = asuint(node.n1.x);
            nodeGroup.y = (hitmask & 0xFF000000) | (asuint(node.n0.w) >> 24);
            triGroup.x = asuint(node.n1.y);
            triGroup.y = hitmask & 0x00FFFFFF;
            hit.steps++;
        }
        else
        {
            triGroup = nodeGroup;
            nodeGroup = uint2(0, 0);
        }
        
        // Process all triangles in the current group
        while (triGroup.y != 0)
        {
            count += 4;
            int triangleIndex = firstbithigh(triGroup.y);
            int triAddr = triGroup.x + (triangleIndex * 3);
            
            // Check intersection and update hit if its closer
            IntersectTriangle(triAddr, ray, hit);
            
            triGroup.y -= 1 << triangleIndex;
        }
        
        if (nodeGroup.y <= 0x00FFFFFF)
        {
            if (stackPtr > 0) 
            { 
                // Pop the stack
                nodeGroup = stack[--stackPtr];
            }
            else
            {
                // Traversal complete, exit loop
                break;
            }
        }
    }

    hit.steps = count;

    if (hit.t < FarPlane)
    {
        TriangleAttributes triAttr = TriangleAttributesBuffer[hit.triIndex];
        hit.normal = normalize(InterpolateAttribute(hit.barycentric, triAttr.normal0, triAttr.normal1, triAttr.normal2));
        hit.position = ray.origin + hit.t * ray.direction;
        hit.material = MaterialBuffer[triAttr.materialIndex];
        hit.uv = InterpolateAttribute(hit.barycentric, triAttr.uv0, triAttr.uv1, triAttr.uv2);
    }
    
    return hit;
}

float3 BackgroundColor(float3 rayDirection)
{
    float yHeight = 0.5f * (-rayDirection.y + 1.0f);
    return (1.0f - yHeight) * float3(1.0f, 1.0f, 1.0f) + yHeight * float3(0.5f, 0.7f, 1.0f);
}

bool ScatterLambertian(RayHit hit, inout Ray ray, inout float3 attenuation, inout uint rngSeed)
{
    ray.origin = hit.position + hit.normal * 0.001f;
    ray.direction = normalize(ray.direction + rngInSphere(rngSeed));
    attenuation = GetAlbedoColor(hit);
    return true;
}

bool ScatterMetal(RayHit hit, inout Ray ray, inout float3 attenuation, inout uint rngSeed)
{
    ray.origin = hit.position + hit.normal * 0.001f;
    float3 reflected = reflect(normalize(ray.direction), hit.normal);
    float smoothness = 1.0f - hit.material.metalicSmoothness.g;
    ray.direction = normalize(reflected + smoothness * rngInSphere(rngSeed));
    attenuation = GetAlbedoColor(hit);

    return dot(ray.direction, hit.normal) >= 0;
}

float reflectance(float cosine, float refractionIndex)
{
    // Use Schlick's approximation for reflectance.
    float r0 = (1.0f - refractionIndex) / (1.0f + refractionIndex);
    r0 *= r0;
    return r0 + (1.0 - r0) * pow((1.0 - cosine), 5.0);
}

bool ScatterDielectric(RayHit hit, inout Ray ray, inout float3 attenuation, inout uint rngSeed)
{
    attenuation = (float3)1.0f;
    //attenuation = GetAlbedoColor(hit);

    float refractRatio = 1.0f / hit.material.ior;
    float3 unitDirection = normalize(ray.direction);
    
    float cosTheta = dot(-unitDirection, hit.normal);
    float sinTheta = sqrt(1.0f - cosTheta * cosTheta);
    bool cannotRefract = (refractRatio * sinTheta) > 1.0f;

    float rnd = rngNextFloat(rngSeed);

    if (cannotRefract || reflectance(cosTheta, refractRatio) > rnd)
    {
        ray.direction = normalize(reflect(unitDirection, hit.normal));
    }
    else
    {
        ray.direction = normalize(refract(unitDirection, hit.normal, refractRatio));
    }

    ray.origin = hit.position + ray.direction * 0.001f;
    
    return true;
}

float3 PathTrace(Ray ray, inout uint rngSeed)
{
    int rayBounces = RAY_BOUNCES;

    float3 color = float3(1.0f, 1.0f, 1.0f);

    while (rayBounces >= 0)
    {
        RayHit hit = CastRayCWBVH(ray);
        if (hit.t < FarPlane)
        {
            float3 attenuation = (float3)0;

            if (hit.material.mode == 3)
            {
                if (!ScatterDielectric(hit, ray, attenuation, rngSeed))
                {
                    return color;
                }
            }
            else
            {
                float metalic = hit.material.metalicSmoothness.r;
                if (metalic > 0.0f)
                {
                    Ray lambertRay = {ray.origin, ray.direction};
                    if (!ScatterMetal(hit, ray, attenuation, rngSeed))
                    {
                        return color;
                    }
                    if (metalic < 1.0f)
                    {
                        float3 lambert = (float3)0;
                        if (!ScatterLambertian(hit, lambertRay, lambert, rngSeed))
                        {
                            return color;
                        }

                        ray.direction = lerp(ray.direction, lambertRay.direction, metalic);

                        attenuation = lerp(attenuation, lambert, metalic);
                    }
                }
                else 
                {
                    if (!ScatterLambertian(hit, ray, attenuation, rngSeed))
                    {
                        return color;
                    }
                }
            }

            color *= attenuation;           
            
            rayBounces--;
        }
        else
        {
            color *= BackgroundColor(ray.direction);
            return color;
        }
    }

    return color;
}

Ray GetScreenRay(float2 pixelCoords)
{
    float3 origin = mul(CamToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;

    // Compute world space direction
    float2 uv = float2(pixelCoords.xy / float2(OutputWidth, OutputHeight) * 2.0f - 1.0f);
    float3 direction = mul(CamInvProj, float4(uv, 0.0f, 1.0f)).xyz;
    direction = mul(CamToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    Ray ray = {origin, direction};
    return ray;
}

[numthreads(256, 1, 1)]
void PathTracer(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= TotalRays)
    {
        return;
    }

    const uint rayIndex = id.x;
    const uint pixelX = rayIndex % OutputWidth;
    const uint pixelY = rayIndex / OutputWidth;
    float2 pixelCoords = float2(pixelX, pixelY);

    uint pixelIndex = pixelY * OutputWidth + pixelX;
    uint rngSeed = RNGStateBuffer[pixelIndex];

    float3 color = 0.0f;
    #if NUM_SAMPLES > 1
    for (int sampleIndex = 0; sampleIndex < NUM_SAMPLES; ++sampleIndex)
    #else
    const int sampleIndex = 1;
    #endif
    {       
        float2 randomSample = float2(rngInRange(0.0, 1.0, rngSeed), rngInRange(0.0, 1.0, rngSeed));
        
        float2 pixelCoordsSample = pixelCoords + randomSample;
        
        Ray ray = GetScreenRay(pixelCoordsSample);

        color += PathTrace(ray, rngSeed);
    }
    #if NUM_SAMPLES > 1
    color /= (float)NUM_SAMPLES;
    #endif

    float3 currentColor = AccumulatedOutput[pixelCoords].rgb;
    float3 accumilatedColor = (color + currentColor * CurrentSample) / (CurrentSample + 1.0f);
    //float3 accumilatedColor = CurrentSample == 0 ? color : color + currentColor;

    Output[pixelCoords] = float4(accumilatedColor, 1.0f);

    RNGStateBuffer[pixelIndex] = rngSeed;
}
