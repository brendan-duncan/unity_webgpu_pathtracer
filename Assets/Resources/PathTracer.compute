#pragma kernel PathTracer

#pragma multi_compile __ HAS_TEXTURES
#pragma multi_compile __ HAS_ENVIRONMENT_TEXTURE
#pragma multi_compile __ HAS_LIGHTS

#include "util/camera.hlsl"
#include "util/common.hlsl"
#include "util/pathtrace.hlsl"
#include "util/random.hlsl"
#include "util/ray.hlsl"

int SamplesPerPass;

// Using a 2D dispatch causes a warning for exceeding the number of temp variable registers.
[numthreads(128, 1, 1)]
//[numthreads(32, 32, 1)]
void PathTracer(uint3 id : SV_DispatchThreadID) {

    const uint pixelIndex = id.x;
    const uint pixelX = pixelIndex % OutputWidth;
    const uint pixelY = pixelIndex / OutputWidth;
    //const uint pixelX = id.x;
    //const uint pixelY = id.y;
    if (pixelX >= OutputWidth || pixelY >= OutputHeight)
        return;

    float2 pixelCoords = float2(pixelX, pixelY);

    const int numSamples = max(1, SamplesPerPass);
    uint rngState = RNGStateBuffer[pixelIndex];

    float3 color = 0.0f;
    for (int sampleIndex = 0; sampleIndex < numSamples; ++sampleIndex)
    {
        float2 randomSample = float2(RandomFloat(rngState), RandomFloat(rngState));

        float2 pixelCoordsSample = pixelCoords + randomSample;

        Ray ray = GetScreenRay(pixelCoordsSample);

        color += PathTrace(ray, rngState);
    }

    if (numSamples > 1)
        color /= (float)numSamples;

    float4 currentColor = AccumulatedOutput[pixelCoords];
    float3 accumilatedColor = (color + currentColor.rgb * CurrentSample) / (CurrentSample + 1.0f);

    Output[pixelCoords] = float4(accumilatedColor, 1.0f);

    RNGStateBuffer[pixelIndex] = rngState;
}
