#pragma kernel PathTracer

#include "util/bvh.hlsl"
#include "util/camera.hlsl"
#include "util/common.hlsl"
#include "util/material.hlsl"
#include "util/random.hlsl"
#include "util/ray.hlsl"
#include "util/scatter.hlsl"
#include "util/sky.hlsl"

#define NUM_SAMPLES 1
#define RAY_BOUNCES 10

float3 PathTrace(Ray ray, inout uint rngSeed)
{
    int rayBounces = RAY_BOUNCES;

    float3 color = float3(1.0f, 1.0f, 1.0f);

    while (rayBounces >= 0)
    {
        RayHit hit = CastRayCWBVH(ray);
        if (hit.t < FarPlane)
        {
            float3 attenuation = (float3)0;

            if (hit.material.mode == 3)
            {
                if (!ScatterDielectric(hit, ray, attenuation, rngSeed))
                {
                    return color;
                }
            }
            else
            {
                float metalic = hit.material.metalicSmoothness.r;
                if (metalic > 0.0f)
                {
                    Ray lambertRay = {ray.origin, ray.direction};
                    if (!ScatterMetal(hit, ray, attenuation, rngSeed))
                    {
                        return color;
                    }
                    if (metalic < 1.0f)
                    {
                        float3 lambert = (float3)0;
                        if (!ScatterLambertian(hit, lambertRay, lambert, rngSeed))
                        {
                            return color;
                        }

                        ray.direction = lerp(ray.direction, lambertRay.direction, metalic);

                        attenuation = lerp(attenuation, lambert, metalic);
                    }
                }
                else 
                {
                    if (!ScatterLambertian(hit, ray, attenuation, rngSeed))
                    {
                        return color;
                    }
                }
            }

            color *= attenuation;           
            
            rayBounces--;
        }
        else
        {
            float3 v = ray.direction;
            float3 s = skyState[0].sunDirection;

            float theta = acos(v.y);
            float gamma = acos(clamp(dot(v, s), -1.0, 1.0));

            float3 radiance = float3(
                skyRadiance(theta, gamma, 0),
                skyRadiance(theta, gamma, 1),
                skyRadiance(theta, gamma, 2)
            );

            color *= radiance * 0.05f;
            return color;

            //color *= BackgroundColor(ray.direction);
            //return color;
        }
    }

    return color;
}

[numthreads(256, 1, 1)]
void PathTracer(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= TotalRays)
    {
        return;
    }

    const uint rayIndex = id.x;
    const uint pixelX = rayIndex % OutputWidth;
    const uint pixelY = rayIndex / OutputWidth;
    float2 pixelCoords = float2(pixelX, pixelY);

    uint pixelIndex = pixelY * OutputWidth + pixelX;
    uint rngSeed = RNGStateBuffer[pixelIndex];

    float3 color = 0.0f;
    #if NUM_SAMPLES > 1
    for (int sampleIndex = 0; sampleIndex < NUM_SAMPLES; ++sampleIndex)
    #else
    const int sampleIndex = 1;
    #endif
    {       
        float2 randomSample = float2(rngInRange(0.0, 1.0, rngSeed), rngInRange(0.0, 1.0, rngSeed));
        
        float2 pixelCoordsSample = pixelCoords + randomSample;
        
        Ray ray = GetScreenRay(pixelCoordsSample);

        color += PathTrace(ray, rngSeed);
    }
    #if NUM_SAMPLES > 1
    color /= (float)NUM_SAMPLES;
    #endif

    float3 currentColor = AccumulatedOutput[pixelCoords].rgb;
    float3 accumilatedColor = (color + currentColor * CurrentSample) / (CurrentSample + 1.0f);

    Output[pixelCoords] = float4(accumilatedColor, 1.0f);

    RNGStateBuffer[pixelIndex] = rngSeed;
}
